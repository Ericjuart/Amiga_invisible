<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Amigo Invisible</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .participant { margin-bottom: 10px; }
    select { margin-left: 10px; }
    button { margin-top: 20px; }
    .error { color: red; font-weight: bold; }
    .message { color: orange; font-weight: bold; }
  </style>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
</head>
<body>
  <h1>Amigo Invisible</h1>
  <p>Introduce los datos del aÃ±o pasado:</p>
  <div id="participants"></div>
  <button onclick="savePreviousData()">Guardar</button>
  <hr>
  <button onclick="validateAndGenerate()">Hacer Sorteo</button>
  <p id="error" class="error"></p>
  <p id="message" class="message"></p>
  <!-- Incluir una animaciÃ³n graciosa -->
  <div id="result" style="display: none; text-align: center;">
    <h2>Â¡El sorteo se ha realizado perfectamente! ðŸŽ‰</h2>
    <p>Revisad vuestros correos o WhatsApp para conocer a quiÃ©n tenÃ©is que regalar.</p>
    <img src="https://media.giphy.com/media/26AHONQ79FdWZhAI0/giphy.gif" alt="AnimaciÃ³n graciosa">
  </div>
  <script>
    const participants = ["Ana", "Laura", "MarÃ­a", "Carmen", "SofÃ­a"]; // Lista de nombres
    const previousData = JSON.parse(localStorage.getItem("previousData")) || {}; // Datos guardados

    let selectedRecipients = {}; // Registro dinÃ¡mico de selecciones

    // Crear la interfaz para elegir resultados del aÃ±o pasado
    function createParticipantFields() {
      const container = document.getElementById("participants");
      container.innerHTML = ""; // Limpia el contenido
      participants.forEach(name => {
        const div = document.createElement("div");
        div.className = "participant";
        div.innerHTML = `${name}: 
          <select id="select-${name}" onchange="handleSelection('${name}')">
            <option value="">Selecciona</option>
            ${participants
              .filter(p => p !== name) // Evitar que alguien se elija a sÃ­ mismo
              .map(p => `<option value="${p}" ${previousData[name] === p ? "selected" : ""}>${p}</option>`)
              .join("")}
          </select>`;
        container.appendChild(div);
      });
      // Actualizar selecciÃ³n inicial
      participants.forEach(name => {
        const selected = previousData[name];
        if (selected) {
          selectedRecipients[name] = selected;
        }
      });
      updateDropdowns();
    }

    // Manejar selecciÃ³n en un desplegable
    function handleSelection(participant) {
      const select = document.getElementById(`select-${participant}`);
      const selectedValue = select.value;

      // Verificar si ya estÃ¡ seleccionado por otro participante
      if (
        selectedValue &&
        Object.values(selectedRecipients).includes(selectedValue) &&
        selectedRecipients[participant] !== selectedValue
      ) {
        document.getElementById("message").innerText = `A ${selectedValue} ya le regalÃ³ ${Object.keys(selectedRecipients).find(key => selectedRecipients[key] === selectedValue)}.`;
        select.value = ""; // Reiniciar selecciÃ³n
        return;
      }

      // Actualizar el registro de selecciones
      if (selectedRecipients[participant]) {
        delete selectedRecipients[participant];
      }
      if (selectedValue) {
        selectedRecipients[participant] = selectedValue;
      }
      document.getElementById("message").innerText = ""; // Limpiar mensaje
      updateDropdowns();
    }

    // Actualizar opciones en los desplegables
    function updateDropdowns() {
      participants.forEach(name => {
        const select = document.getElementById(`select-${name}`);
        const currentValue = select.value;
        Array.from(select.options).forEach(option => {
          if (option.value && option.value !== currentValue) {
            option.disabled = Object.values(selectedRecipients).includes(option.value);
          } else {
            option.disabled = false;
          }
        });
      });
    }

    // Guardar los datos del aÃ±o pasado
    function savePreviousData() {
      participants.forEach(name => {
        const selected = document.getElementById(`select-${name}`).value;
        if (selected) {
          previousData[name] = selected;
        }
      });
      localStorage.setItem("previousData", JSON.stringify(previousData));
      alert("Datos guardados correctamente.");
    }

    // Validar que todos los campos estÃ¡n completos
    function validateAndGenerate() {
      const errorElement = document.getElementById("error");
      errorElement.innerText = ""; // Limpiar mensajes de error

      const allFilled = participants.every(name => {
        const selected = document.getElementById(`select-${name}`).value;
        return selected && selected !== "";
      });

      if (!allFilled) {
        errorElement.innerText = "Por favor, selecciona destinatarios para todas las participantes antes de hacer el sorteo.";
        return;
      }

      generateRandomPairs();
    }

// Inicializar EmailJS (obtÃ©n tu userID desde EmailJS)
    emailjs.init("G45KEugA7gjmqCxx5");

    const participantsData = [
        { name: "Ana", email: "ericjuarez11@gmail.com", image: "https://drive.google.com/uc?export=view&id=1CPgGF0DOHektZ-RztyAqzlTm4mzAfha1" },
        { name: "Laura", email: "ericjuarez11@gmail.com", image: "https://ih1.redbubble.net/image.1387091196.7732/st,small,845x845-pad,1000x1000,f8f8f8.jpg" },
        { name: "MarÃ­a", email: "ericjuarez11@gmail.com", image: "https://ih1.redbubble.net/image.1387091196.7732/st,small,845x845-pad,1000x1000,f8f8f8.jpg" },
        { name: "LucÃ­a", email: "ericjuarez11@gmail.com", image: "https://ih1.redbubble.net/image.1387091196.7732/st,small,845x845-pad,1000x1000,f8f8f8.jpg" }
    ];

    // Generar el sorteo aleatorio respetando restricciones
    function generateRandomPairs() {
        let valid = false;
        let pairs = {};

        while (!valid) {
            pairs = {};
            let remaining = [...participantsData.map(p => p.name)];

            for (const participant of participantsData) {
                const validOptions = remaining.filter(
                    (p) => p !== participant.name && previousData[participant.name] !== p
                );

                if (validOptions.length === 0) {
                    pairs = {};
                    break;
                }

                const chosen = validOptions[Math.floor(Math.random() * validOptions.length)];
                pairs[participant.name] = chosen;
                remaining = remaining.filter((p) => p !== chosen);
            }

            valid = Object.keys(pairs).length === participantsData.length && remaining.length === 0;
        }

        // Mostrar mensaje de Ã©xito y enviar los resultados
        document.getElementById("result").style.display = "block";
        sendResults(pairs);
    }

    // Enviar los resultados por correo
    function sendResults(pairs) {
        for (const participant of participantsData) {
            const recipientName = pairs[participant.name];
            const recipientData = participantsData.find(p => p.name === recipientName);

            // Crear el correo personalizado
            const emailParams = {
                to_name: participant.name,
                to_email: participant.email,
                recipient_name: recipientData.name,
                recipient_image: recipientData.image
            };

            // Usar un servicio de plantilla de EmailJS
            emailjs.send("service_eea4prs", "template_dutsp6t", emailParams)
                .then(() => {
                    console.log(`Correo enviado a ${participant.name}`);
                })
                .catch((error) => {
                    console.error(`Error al enviar correo a ${participant.name}:`, error);
                });
        }
    }

    // Inicializar la interfaz
    createParticipantFields();

  </script>
  
</body>
</html>
